
package xj.mobile.tool

import groovy.xml.MarkupBuilder

import xj.mobile.lang.*
import xj.mobile.util.NDBuilder

import xj.mobile.model.properties.*
import xj.mobile.api.*

import org.ho.yaml.Yaml

import static xj.mobile.lang.Attributes.*
import static xj.mobile.util.CommonUtil.decodeAttributeValue

/*
 *
 * Depends-on:
 *   APIResolver: lib/api
 *     depends-on: doc reader, (all platforms)
 *
 * Generates:
 *   language doc in test/lang/def
 *   test/lang/PlatformTypeNames.yml 
 */
class Lang { 

  static String natural = 'scripts/NaturalDocs'

  static String base = 'test/lang'

  static boolean framed = false
  static boolean showSystemAttributes = false  // true
  static boolean showExampleValues = true

  static String footerText = 'Copyright &copy; 2013 Generated by Mobile App Builder'

  public static void main(String[] args) {
    boolean langdef = false
    for (s in args) { 
      switch (s) { 
      case '-def': langdef = true; break;
	  case '-framed': framed = true; break;
      } 
    }
    if (langdef) { 
      outputLangDef() 
	  writePlatformTypes()
    } else { 
      Language.definitions.each { name, entry ->
		print name + ' '
      }
    }
  }

  static outputLangDef() { 
	println "Output lanaguage definition in ${base}/def"

    def attrMap = attributesMap()

    prepare()

	def neutralNames = []
	def androidNames = []
	def iosNames = []
	Language.definitions.each { name, entry ->
	  if (Language.Platform.Neutral in entry.platforms) { 
		neutralNames << name
	  }
	  if (Language.Platform.Android in entry.platforms) { 
		androidNames << name
	  }
	  if (Language.Platform.iOS in entry.platforms) { 
		iosNames << name
	  }
	}

	def sections = [ 'System' : [ 'app' ],
					 'UI.Neutral' : neutralNames, 
					 'UI.Android' : androidNames, 
					 'UI.iOS' : iosNames,
					 'Data Types' : DataTypes.typeNames, 
				   ]
	if (framed) { 
	  buildIndexTocPage(sections)
	}
    buildMainPage(sections)
	buildDefPages(sections, attrMap)

  }

  static prepare() { 
    def d1= new File(base + '/def/css')
    def d2= new File(base + '/def/script')
    d1.mkdirs()
    d2.mkdirs()

    //new File(base + '/css/output.css').text = new File('scripts/output.css').text

	// Natural Docs style 
    def ndJS = new File("${natural}/script").list(
      {d, f-> f ==~ /.*\.js/ } as FilenameFilter
    ).toList().each { js -> 
      new File("${base}/def/script/${js}").text = new File("${natural}/script/${js}").text
    }
    def ndCSS = new File("${natural}/style").list(
      {d, f-> f ==~ /.*\.css/ } as FilenameFilter
    ).toList().each { css -> 
      new File("${base}/def/css/${css}").text = new File("${natural}/style/${css}").text
    }
  }

  static buildIndexTocPage(sections) { 
    def indexFile = new FileWriter(base + '/def/index.html')
    def indexBuilder = new MarkupBuilder(indexFile)    
    indexBuilder.setDoubleQuotes(true)
    indexBuilder.html { 
      head { 
		meta('http-equiv': 'Content-Type', content: 'text/html; charset=UTF-8')
		title 'MADL Defnition'
      }
      frameset('cols': '185,*') { 
		frame(name: 'toc', src: 'toc.html')
		frame(name: 'display', src: 'summary.html')
      }
    }
    indexFile.close()

    def tocFile = new FileWriter(base + '/def/toc.html')
	def tocBuilder = new NDBuilder(tocFile)
    tocBuilder.html { 
	  ndhead('Menu')
	  ndbody(framed) { 
		buildMenu(tocBuilder, sections)
	  }
    }
    tocFile.close()
  }

  static buildMenu(builder, sections, selected = null) { 
	builder.div(id: 'Menu') {
	  
	  // generate summary entry
	  def summaryName = framed ? 'summary' : 'index'
	  div(class: 'MEntry') { 
		if (selected == summaryName) { 
		  div(class: 'MFile', id: 'MSelected') { 
			mkp.yieldUnescaped('Summary')
		  }
		} else { 
		  div(class: 'MFile') { 
			if (framed)
			  a(target: 'display', href: "${summaryName}.html", 'Summary')
			else 
			  a(href: "${summaryName}.html", 'Summary')
		  }
		}
	  }

	  int scount = 1
	  sections.each { title, names ->
		div(class: 'MEntry') { 
		  div(class: 'MGroup') { 
			a(href: "javascript:ToggleMenu(\'MGroupContent${scount}\')", target: '_self') { 
			  mkp.yield(title) 
			}
			div(class: 'MGroupContent', id: "MGroupContent${scount}", style: 'display: block; ') { 
			  names.sort().each { name -> 
				div(class: 'MEntry') {
				  if (name == selected) { 
					div(class: 'MFile', id: 'MSelected') { 
					  mkp.yieldUnescaped(name)
					}
				  } else { 
					div(class: 'MFile') { 
					  if (framed)
						a(target: 'display', href: "${pageName(title,name)}.html", name)
					  else 
						a(href: "${pageName(title,name)}.html", name)
					}
				  }				 
				}
			  }
			}
		  }
		}
	  }
	  scount++
	}
  }

  static buildMainPage(sections) { 
    def pageTitle = 'MADL Defnition'
	def fname = framed ? 'summary' : 'index'
    def mainFile = new FileWriter("${base}/def/${fname}.html")
    def mainBuilder = new NDBuilder(mainFile)    
	mainBuilder.html { 
	  ndhead(pageTitle) 
	  ndbody(framed) { 
		div(id: 'Content') { 
		  ndtopic(pageTitle, 'main', 1, null) //{ mkp.yieldUnescaped(' ') }
		  Language.ViewType.values().each { vtype ->
			ndgroup(vtype, vtype, 2) { //mkp.yieldUnescaped(' ') }

			  table(border: '0', cellspacing: '0', cellpadding: '0', class: 'CDescriptionList') { 
				tbody {
				  Language.definitions.keySet().sort().each { name -> 
					def vdef = Language.definitions[name]
					if (vdef.type == vtype) { 
					  tr { 
						td(class: 'CDLEntry') { 
						  a(href: "Widget_${name}.html", name)
						  //mkp.yield(name)
						}
						td(class: 'CDLDescription') { 
						  mkp.yield(vdef.platforms)
						}
					  }
					}
				  }
				}
			  }
			} 
		   
		  }
		  
		}

		if (!framed) { 
		  footer(footerText)
		  buildMenu(mainBuilder, sections, fname)
		}
	  }
	}
	mainFile.close()
  }

  static buildDefPages(sections, attrMap) { 
	sections.each { title, names ->
	  names.each { name -> 
		generateDefPage(title, name, sections, attrMap)
	  }
	}
  }

  static pageName(title, name) { 
	def prefix = title
	if (title[0..2] == 'UI.') { 
	  prefix = 'Widget'
	} else if (title == 'Data Types') { 
	  prefix = 'Type'
	} //else if (title == 'System') { 
	"${prefix}_${name}"
  }

  static generateDefPage(title, name, sections, attrMap) { 
    def defFile = new FileWriter("${base}/def/${pageName(title,name)}.html")
    def defBuilder = new NDBuilder(defFile)    
    defBuilder.html { 
	  ndhead("${title}: ${name}", null)
	  ndbody(framed) { 
		def pageContent = 'defaultContent'
		if (title[0..2] == 'UI.') { 
		  pageContent = 'widgetContent'
		} else if (title == 'System') { 
		  pageContent = 'systemContent'
		} else if (title == 'Data Types') { 
		  pageContent = 'dataTypeContent'
		} 

		"${pageContent}"(defBuilder, title, name, attrMap)

		if (!framed) { 
		  footer(footerText)
		  buildMenu(defBuilder, sections, name)
		}
      }
    }
    defFile.close()
  }

  static widgetContent(builder, title, name, attrMap) { 
	builder.div(id: 'Content') { 
	  def entry = Language.definitions[name]
	  def attrNames = attrMap[name].collect { it.name } // exclude these names in platform attributes  

	  println "[widgetCOntent] ${name} attrNames ---\n${attrNames.join('\n')}\n------------\n"

	  def aliases = []
	  attrNames.each { n ->
		def a = AttributeMap.commonAliases[n]
		if (a) { 
		  if (a instanceof List) { 
			aliases.addAll(a)
		  } else { 
			aliases.add(a)
		  }
		}
	  }

	  def widgetPropMap = [:]   // platform attributes 
	  def widgetMethodMap = [:] // platform methods 
	  def nativeClasses = [:]
	  if (entry.platforms.contains(Language.Platform.Neutral) &&
		  WidgetMap.widgets[name]) { 
		[ 'iOS', 'Android' ].each { pname ->
		  def p = pname.toLowerCase()
		  def nativeNames = ''
		  def pwname = WidgetMap.widgets[name][p]
		  if (pwname instanceof List) { 
			nativeNames = pwname.collect { WidgetMap.getNativeWidgetName(it, p) }
		  } else { 
			nativeNames = WidgetMap.getNativeWidgetName(pwname, p)
		  }
		  nativeClasses[pname] = nativeNames

		  APIResolver api = APIResolver.getAPIResolver(pname)
		  def nativeName = (nativeNames instanceof List)? nativeNames[0] : nativeNames
		  if (nativeName) { 
			int i = nativeName.lastIndexOf('.')
			if (i > 0) nativeName = nativeName[i + 1 .. -1]
			//def props = api.findAllPropertyDefs(nativeName, attrNames + aliases)
			def props = api.findAllPropertyDefs(nativeName)
			if (props) { 
			  widgetPropMap[pname] = props

			  println "[widgetContent] ${name} props ---\n${props.keySet().join('\n')}\n------------\n"

			}
			def methods = api.findAllMethodDefs(nativeName)
			if (methods) { 
			  widgetMethodMap[pname] = methods
			  println "[widgetContent] ${name} methods ---\n${methods.keySet().join('\n')}\n------------\n"
			}
		  }

		}
	  }
	  def pattrToc = []
	  if (widgetPropMap) { 
		[ 'iOS', 'Android' ].each { pname ->
		  if (widgetPropMap[pname]) { 
			pattrToc << [ "${pname} Attributes", "${pname}_attributes" ]
		  }
		}
	  }

	  def attrGroups = getAttributeGroups(name, attrMap)
	  def toc = [
		[ 'Widget Type', 'type' ],
		[ 'Supported Platforms', 'platforms' ]
	  ] + getTocList(attrGroups) + pattrToc
	  

	  ndtopic("UI Widget: ${name}", "${name}", 1) { 
		ndtoc(toc)
	  }

	  ndgroup('Widget Type', 'type', 2) { 
		ul { 
		  li entry.type
		}
	  }

	  ndgroup('Supported Platforms', 'platforms', 2) { 
		ul { 
		  entry.platforms.each { p -> 
			li p
		  }
		}
	  }
	  
	  if (entry.platforms.contains(Language.Platform.Neutral) && nativeClasses) { 
		builder.ndtopic('Native Widget Class Mapping', 'widget_mapping', 3) {
		  ul { 
			[ 'iOS', 'Android' ].each { pname ->
			  li ("Native class for ${pname}: ${nativeClasses[pname]}") { 
				mkp.yieldUnescaped(' ')
			  }
			}
		  }
		}
	  }
		
	  attributeContents(builder, name, attrGroups)

	  platformAttributeContents(builder, name, widgetPropMap)

	  platformMethodContents(builder, name, widgetMethodMap)
	}
  }

  static systemContent(builder, title, name, attrMap) { 
	builder.div(id: 'Content') { 
	  def attrGroups = getAttributeGroups(name, attrMap)
	  def toc = getTocList(attrGroups)

	  ndtopic("System: ${name}", "${name}", 1) { 
		ndtoc(toc)
	  }

	  attributeContents(builder, name, attrGroups)
	}
  }

  static dataTypeContent(builder, title, name, attrMap) { 
	builder.div(id: 'Content') { 

	  ndtopic("Data Type: ${name}", "${name}", 1) { 
		//ndtoc(toc)
		mkp.yieldUnescaped(' ')
	  }

	  if (name == 'Color') { 
		ndgroup('Constants', 'constants', 2) {
		  ndtopic('Common Color Names', 'common_names', 3) {
			ul { 
			  Color.colorMap.keySet().sort().each { cname -> 
				li cname
			  }
			}
		  }
		  ndtopic('HTML Color Names', 'html_names', 3) {
			ul { 
			  Color.htmlColorNames.keySet().sort().each { cname -> 
				li cname
			  }
			}
		  }
		}
	  } else { 
		Class clazz = "xj.mobile.model.properties.${name}" as Class
		if (clazz) { 
		  ndgroup('Constants', 'constants', 2) {
			ul { 
			  clazz.values.keySet().sort().each { cname -> 
				li cname
			  }
			}
		  }
		}
	  }

	}
  }

  static defaultContent(builder, title, name) { 
	builder.div(id: 'Content') { 
	  ndtopic("${title}: ${name}", "${name}", 1, null) 
	}
  }

  static skipNames = [
	'id', // unique id 
	'next', // state/view id 
	'name', 'title', 'subtitle', 'shotTitle', 'text', 'message', 'menu', 'detailText', 'prompt', // any string 
	'#pos' 
  ]

  static skipTypes = [
	'Closure', 'int', 'float'
  ]

  static skipAttrValue(attr) { 
	(attr.name in skipNames) || (attr.type in skipTypes)
  }
  
  static numTypes = [ 'int', 'float' ] as Set
  
  static processAttributeSet(attrSet) { 
	def result = []
	attrSet?.each { a ->

	  // unify types: Integer and BigDecimal
	  def attr = result.find { it.name == a.name && 
		(it.type == a.type || it.type in numTypes && a.type in numTypes) }
	  if (attr && a.type != attr.type) { // must be number type 
		attr.type = 'float'
	  }

	  if (attr == null) { 
		// unify types: null and another type 
		attr = result.find { it.name == a.name && (it.type == 'null' || a.type == 'null') }
		if (attr && attr.type == 'null') { 
		  attr.type = a.type
		}
	  }

	  if (attr) { 
		if (!skipAttrValue(a)) {
		  attr.values << a.value
		}		
	  } else { 
		attr = [name: a.name, type: a.type]
		if (!skipAttrValue(a)) { 
		  attr.values = [ a.value ] as Set
		}
		result << attr
	  }
	}
	return result
  }

  static breakMapType(mtype) { 
	if (mtype && mtype.startsWith('Map<')) { 
	  def map = [:]
	  mtype[4 .. -2].split(',').each { 
		int i = it.indexOf(':')
		if (i > 0) { 
		  map[it[0 .. i-1]] = it[i+1 .. -1]
		}	      
	  } 
	  return map
	}
	return mtype
  }

  static getAttributeGroups(name, attrMap) { 
	def attrGroups = null
	def attrSet = attrMap[name]
	if (attrSet) { 
	  attrGroups = [
		'Attributes' : processAttributeSet(attrSet.findAll { it.name != 'classes' && it.name[0] != '#' && it.name[0] != '@' }),
		'Annotations' : processAttributeSet(attrSet.findAll { it.name[0] == '@' }),
		'System Attributes' : showSystemAttributes ? processAttributeSet(attrSet.findAll { it.name[0] == '#' }) : null,
	  ]
	}

	if (!attrGroups || !attrGroups['Attributes']) { 
	  println "!!! Warning: ${name}: has no attribute."
	} else { 
	  def attrNames = attrGroups['Attributes'].name
	  attrGroups['Attributes'].name.unique().each { 
		if (attrNames.count(it) > 1) { 
		  println "!!! Warning: ${name}: multiple entries of attribute ${it}."
		}
	  }
	}
  
	return attrGroups
  }

  // for generating TOC at the top of the page, list of [name, anchor] 
  static getTocList(attrGroups) { 
	def toc = []
	attrGroups?.each { name, list ->
	  if (list) toc << [ name, name.toLowerCase() ]
	}
	return toc
  }

  static attributeContents(builder, name, attrGroups) { 
	attrGroups?.each { gname, glist ->
	  if (glist) { 
		builder.ndgroup(gname, gname.toLowerCase(), 2) { 
		  def names = glist.collect{ it.name }.unique().sort()
		  ndsummary('Summary', names.collect{ [it, it, glist.findAll{ attr -> attr.name == it }.type.toString()[1..-2]] })
		}

		glist.sort { it.name }.each { attr ->
		  builder.ndtopic(attr.name, attr.name, 3) { 
			def attrDesc = getAttributeDescription(attr.name)
			def attrDef = getAttributeDef(attr.name)
			if (attrDesc) { 
			  p { 
				mkp.yield(attrDesc)
			  }
			}

			ul { 
			  if (attr.type.startsWith('Map<')) { 
				def map = breakMapType(attr.type) 
				li('Type: Map') {
				  ul { 
					map.each { mkey, mtype -> 
					  li("${mkey}: ${mtype}") { 
						mkp.yieldUnescaped(' ') 
					  }
					}
				  }
				}
			  } else if (attr.type.startsWith('List<Map<')) { 
				def map = breakMapType(attr.type[5 .. -2]) 
				li('Type: List<Map>') {
				  ul { 
					map.each { mkey, mtype -> 
					  li("${mkey}: ${mtype}") { 
						mkp.yieldUnescaped(' ') 
					  }
					}
				  }
				}
			  } else { 
				//li('Type: ' + attr.type) { mkp.yieldUnescaped(' ') }
				li('Type: ') { 
				  if (attr.type in DataTypes.typeNames) { 
					a(href: "Type_${attr.type}.html", attr.type)
				  } else { 
					mkp.yield(attr.type)
				  }
				}
			  }

			  if (attrDef?.restriction) { 
				li('Restriction: ') { 
				  mkp.yield(attrDef?.restriction)
				}
			  }

			  if (showExampleValues && attr.values) { 
				li('Examples of value: ') { 
				  ul { 
					attr.values.each { v -> 
					  li { mkp.yield(decodeAttributeValue(v.toString())) }
					  //li { mkp.yield(v.toString().replaceAll(';', ',')) }
					}
				  }
				}
			  }
			}
		  }
		}		 
	  }
	}
  }


  //
  //  compile attribute info from attribute files generated during execution 
  //

  static typeMap = [
	'Integer'    : 'int',
	'BigDecimal' : 'float',
	'Boolean'    : 'boolean'
  ]

  static attributesMap() { 
    def attrMap = [:]

    new File(base).list(
      {d, f-> f ==~ /.*-attr\.txt/ } as FilenameFilter
    ).toList().each { fname -> 
      def file = new File("${base}/${fname}")
      //println "Process ${fname}"

      def name = null
      def set = [] as Set
      
      file.eachLine { line -> 
		if (line.size() > 0) { 
		  if (line[0] != '\t') {
			if (name) { 
			  attrMap[name] = set
			}
			name = line
			set = attrMap[name]
			if (set == null) { 
			  set = [] as Set
			}
		  } else if (line.indexOf('[') >= 0) { 
			def map = [:]
			line[2 .. -2].split(', ').each { 
			  int i = it.indexOf(':')
			  if (i > 0) { 
				map[it[0 .. i-1]] = it[i+1 .. -1]
			  }	      
			}
			map['file'] = fname[0..-10]

			// standardize type name 
			def type = map['type']
			if (type) { 
			  typeMap.each { t1, t2 -> 
				type = type.replaceAll(t1, t2)
			  }
			  map['type'] = type
			}
			set.add(map)
		  }
		}
      }
      attrMap[name] = set
    }

	/*
    println attrMap
	attrMap.each{ key, value ->
	  def vstr = value.sort { it.name }.join('\n\t')
	  println "${key}\n\t${vstr}"
	}
	*/

    return attrMap
  }


  /////

  static platformTypeNames = [ 'iOS': [:], 'Android': [:] ]

  static addPlatformTypeName(platform, type, widgetName, propName) { 
	println "===== addPlatformTypeName: propName=${propName} type=${type}"

	def types = platformTypeNames[platform]
	def context = [widgetName, propName]
	if (types != null) { 
	  if (types[type]) {  
		types[type] << context
	  } else { 
		types[type] = [ context ]
	  }
	} else { 
	  types = [ type: [ context ] ]
	}
  }

  static writePlatformTypes() { 
	Yaml.dump(platformTypeNames, new File(base + '/PlatformTypeNames.yml'), true)
  }

  static platformAttributeContents(builder, name, widgetPropMap) { 
	if (name) { 

	  [ 'iOS', 'Android' ].each { platform ->
		def props = widgetPropMap[platform]
		if (props) { 
		  builder.ndgroup("Platform Attributes: ${platform}", "${platform}_attributes", 2) { 
			def names = props.keySet().sort()
			ndsummary('Summary', names.collect{ [it, "${platform}:${it}", props[it]?.type] })
			
			//mkp.yieldUnescaped(' ')
		  }

		  props.keySet().sort().each { pname ->
			addPlatformTypeName(platform, props[pname].type, name, pname)

			builder.ndtopic(pname, "${platform}:${pname}", 3) {
			  def desc = props[pname].description
			  if (desc) { 
				p { 
				  mkp.yieldUnescaped(desc)
				}
			  }
			  ul { 
				li('Type: ' + props[pname].type) { mkp.yieldUnescaped(' ') }
			  }
			}
		  }
		}

	  }


	}
  }

  static platformMethodContents(builder, name, widgetMethodMap) { 
	if (name) { 

	  [ 'iOS', 'Android' ].each { platform ->
		def methods = widgetMethodMap[platform]
		if (methods) { 
		  methods.keySet().sort().each { mname ->
			def mdef = methods[mname]
			if (mname.startsWith('add') && 
				mdef.args.size() == 1) { 
			  //def args = mdef.args

			  addPlatformTypeName(platform, mdef.args[0].type.name, name, mname)
			}
		  }
		}
	  }
	}
  }


}